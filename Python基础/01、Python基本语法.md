Python简介

```python
Python简介：
	编译型语言和解释型语言
	编译型：
            优点：编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。
            缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
    解释型：
            优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
            缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。
Python发展历史
            Python的创始人为吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为ABC语言的一种继承。
            1989年，为了打发圣诞节假期，Guido开始写Python语言的编译器。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus。他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。
            1991年，第一个Python编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。从一出生，Python已经具有了：类，函数，异常处理，包含表和词典在内的核心数据类型，以及模块为基础的拓展系统。
			Granddaddy of Python web frameworks, Zope 1 was released in 1999
			Python 1.0 - January 1994 增加了 lambda, map, filter and reduce.
			Python 2.0 - October 16, 2000，加入了内存回收机制，构成了现在Python语言框架的基础
			Python 2.4 - November 30, 2004, 同年目前最流行的WEB框架Django 诞生
			Python 2.5 - September 19, 2006
			Python 2.6 - October 1, 2008
			Python 2.7 - July 3, 2010
			In November 2014, it was announced that Python 2.7 would be supported until 2020, and reaffirmed that there would be no 2.8 release as users were expected to move to Python 3.4+ as soon as possible
			Python 3.0 - December 3, 2008
			Python 3.1 - June 27, 2009
			Python 3.2 - February 20, 2011
			Python 3.3 - September 29, 2012
			Python 3.4 - March 16, 2014
			Python 3.5 - September 13, 2015
		Python2和Python3的区别：
			Python 2是遗留的，Python 3是语言的现在和未来。
            
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

什么是编程语言，什么是语言，为什么要有编程语言？
    语言就是一种事物与另外一种事物沟通的表达方式/工具，编程语言的本质就是一门语言
    
什么是编程，为什么要编程？
    编程就是人把自己想让计算机做的事，也就是自己的思维逻辑，用编程语言表达出来
    编程的目的就是让计算机按照人类的思维逻辑去工作，从而解放人力。
    
编程语言的分类：
    机器语言：
        机器语言是站在计算机的角度，说计算机能听懂的语言，机器语言的实质就是直接用二进制编程
        
    汇编语言：
        汇编语言是指用一个英文标签代表一组二进制指令，汇编语言的本质仍然是直接操作硬件
        
    高级语言：
        编译型：
            编译器一般会有预编译的过程对代码进行优化。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。可以脱离语言环境独立运行。但是编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。
            
        解释型：
            有良好的平台兼容性，在任何环境中都可以运行，前提是安装了了解释器。修改代码的时候直接修改就可以，可以快速部署，不用停机维护。
            
    比较：
        1、执行效率：机器语言>汇编语言>高级语言（编译型>解释型）

        2、开发效率：机器语言<汇编语言<高级语言（编译型<解释型）

        3、跨平台性：解释型具有极强的跨平台型

Python语言和Python解释器的区别：
    python语言：指的是pyton的语法风格
    python解释器：专门用来识别python这门语言的语法并解释执行的程序

Python解释器的类型：
    CPython：官方下载的就是
    Jython：是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。
    pypy：


运行Python程序的两种方式：
    1、交互式：
        即时得到程序的运行结果，多用于调试
    2、脚本：
        将程序写到文件里，然后用python解释器解释执行其中的内容

注释：
    什么是注释：
        注释就是就是对代码的解释说明，注释的内容不会被当作代码运行
    为什么要注释：
        提高代码的可读性
    如何使用注释：
        #：单行注释
        ''' '''或 """ """：多行注释
    两个原则：
        1、不用全部加注释，只需要为自己觉得重要或不好理解的部分加注释即可
        2、注释可以用中文或英文，但不要用拼音


```

Python解释器的安装

```python
下载安装包:
	https://www.python.org/downloads/release/
安装:
	默认安装路径：C:\python27
	配置环境变量
		【右键计算机】--》【属性】--》【高级系统设置】--》【高级】--》【环境变量】--》【在第二个内容框中找到 变量名为Path 的一行，双击】 --> 【Python安装目录追加到变值值中，用 ； 分割】
        
第一个Python程序
	创建一个文件，直接以.py为后缀，然后写入内容
		print("Hello World!")
```

python基本语法之变量

```pytohn
什么是变量：
    变量就是可以变化的量，量指的是事物的状态，比如人的年龄、性别等等
    变量用于存储在计算机程序中引用和操作的信息。它们还提供了一种用描述性名称对数据进行标记的方法，这样我们的程序就可以更清楚地被读者和我们自己理解。把变量看作容纳信息的容器是有帮助的。他们唯一的目的是在内存中标记和存储数据。然后可以在整个程序中使用这些数据。
     Python环境中不区分常量和变量，所有的变量都是可变的，为了区分常量和变量，一般全部大写的为常量，小写的为变量
     
变量的组成：
    变量名，赋值符号，变量值
    
变量的三大特征：
    id：反映的是变量值的内存地址，内存地址不同id则不同
    type：变量的类型，不同类型的值用来表示记录不同的状态
    value：变量值本身

变量的命名规则：
    变量名只能是 字母、数字或下划线的任意组合，不可以是特殊字符或者空格
    变量名的第一个字符不能是数字
    以下关键字不能声明为变量名
        ['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield']
    变量的创建：变量=变量值
    变量的删除：del 变量名

变量的命名风格：
    驼峰体：首字母大写
    纯小写加下划线（推荐）

字符编码
    支持中文的第一张表GB2312
    支持所有语言：Unicode，一个字符占用两个字节
    Unicode的扩展及UTF-8。是一个可变长的字符编码
        Python2.x默认编码assic
        Python3.x默认编码Unicode

```

python基本数据类型

```pytohn
什么是数据类型：
    说明数据的数据宽度、数据结构、数据的使用场景
    
数字类型：
    int整型
        用来记录人的年龄，出生年份，学生人数等整数相关的状态
        age = 18   print(type(age))
    float浮点型:
        用来记录人的身高，体重，薪资等小数相关的状态.
        weight=123.45
        print(type(weight))

字符串类型：
    Str：
        用来记录人的名字，家庭住址，性别等描述性质的状态
        在Python中,凡是用引号引起来的,全是字符串
        字符串之间可以相加，但仅限于str与str之间进行
        name="xiaoming"
        print(type(name))
    注：
        用单引号、双引号、多引号，都可以定义字符串，本质上是没有区别的，但是需要考虑引号嵌套的配对问题，若内部有单引号，则外层需要用双引号；多引号可以写多行字符串

列表类型：
    list：
        在[]内用逗号分隔开多个任意类型的值，一个值称之为一个元素
        用来记录多个同种属性的值。
        列表类型是用索引来对应值，索引代表的是数据的位置，从0开始计数
        索引反映的是顺序、位置，对值没有描述性的功能

        stu_names=['张三','李四','王五']                      #d定义
        print(type(stu_names))                             #查看类型
        print(stu_names[0])        
        列表可以嵌套，嵌套取值如下
            students_info=[['tony',18,['jack',]],['jason',18,['play','sleep']]]
            students_info[0][2][0]      #取出第一个学生的第一个爱好

字典类型：
    dict：
        用来记录来记录多个值，但多个值是不同属性的；
        字典类型是用key：value形式来存储数据，其中key可以对value有描述性的功能
        value可以是任意类型，但是key必须是不可变类型
        person_info={'name':'tony','age':18,'height':185.3}      #定义一个字典
        person_info['name']

        字典同样可以进行嵌套
        >>> students=[
        ... {'name':'tony','age':38,'hobbies':['play','sleep']},
        ... {'name':'jack','age':18,'hobbies':['read','sleep']},
        ... {'name':'rose','age':58,'hobbies':['music','read','sleep']},
        ... ]
        >>> students[1]['hobbies'][1] #取第二个学生的第二个爱好
        'sleep'

元组：
    元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。
    元组中的元素类型可以不相同；

        tpl = ('aa','bb','cc',11,22,3.14,{"key":"value"},[1,2,3])
        print(type(tpl))
        print(tpl)

布尔类型：
    bool
        用来记录真假两种状态，通常用来当作判断的条件

如何选择合适的类型来记录状态
    1、选取的类型是否可以明确标识事物的状态
    2、存不是目的，存的目的是为了日后取出来用，并且方便的用
    3、把自己想象成一台计算机，如果我是计算机，
        我会如何以何种形式把事物的状态记到脑子里， 然后再去python中找相应的数据类型来让计算机像自己一样去记下事物的状态

IS与==
    is：比较左右两个值身份id是否相等
    ==：比较左右两个值他们的值是否相等

    id不同的情况下，值有可能相同，即两块不同的内存空间里可以存相同的值
    id相同的情况下，值一定相同，x is y成立，x == y也必然成立

```

自动类型转换

```python
精度从低向高进行转换 : bool -> int -> float -> complex
自动类型转换,默认从低精度向高精度进行转换(从低到高)
自动类型转换是针对数字类型来说的

```

容器类型的强制转换

```python
容器类型的强制转换 (str  list tuple set dict)
    str 
    Number类型数据 str都可以转换
    规律:基于原来的数据类型两边套上引号

    list 
    规律: 如果是字符串,把里面的字符一个一个拿出来,作为列表的每一个元素
          如果是其他容器数据,只是基于原数据,把两边的符号换成[] , 换成列表
          如果是字典,只是单纯的获取字典的键,不要那个值,组成列表

    tuple
    规律:如果是字符串,把里面的字符一个一个拿出来,作为元组的每一个元素
          如果是其他容器数据,只是基于原数据,把两边的符号换成() , 换成元组
          如果是字典,只是单纯的获取字典的键,不要那个值,组成元组

    set
    规律:如果是字符串,把里面的字符一个一个拿出来,作为集合的每一个元素
          如果是其他容器数据,只是基于原数据,把两边的符号换成{} , 换成集合
          如果是字典,只是单纯的获取字典的键,不要那个值,组成集合
        集合的特征:自动去重,无序

    dict 强转字典
    需要等长的二级容器,并且元素的总个数是2个;
    字符串元素个数只能是1个,多一个都不行,有局限性,不推荐使用
```

变量的缓存机制

```python
缓存机制
	只有两个值相同,就只开辟一个空间

Number部分
	1.对于整型而言，-5~正无穷范围内的相同值 id一致   小整数池
        var1 = 100
        var2 = 100
        var1 = -6
        var2 = -6
        var1 = var2 = -100 # 相同的地址
        print(id(var1)   , id(var2))
        
	2.对于浮点型而言，非负数范围内的相同值，id一致
    	var1 = -5.76
        var2 = -5.76
        print( id(var1) , id(var2) )

	3.对于布尔值而言，值相同的情况下，id一致
    	var1 = True
        var2 = False
        print( id(var1) , id(var2) )
        
	4.复数在 实数+虚数 这样的结构中永不相同(只有虚数的情况例外)
        var1 = 3+4j 
        var2 = 3+4j
        var1 = 90j
        var2 = 90j
        print( id(var1) , id(var2) )
        
容器类型部分：
	1.字符串 和 空元组 相同的情况下，地址相同
    	var1 = "你"
        var2 = "你"
        var1 = ()
        var2 = ()
        print( id(var1) , id(var2) )
        
	2.列表，元组，字典，集合无论什么情况 id标识都不同 [空元组例外]
        var1 = (1,2,3)
        var2 = (1,2,3)
        print( id(var1) , id(var2) )
    
```





Python垃圾回收机制

```python
什么是垃圾回收机制：
	垃圾回收机制（简称GC）是Python解释器自带一种机制，专门用来回收不可用的变量值所占用的内存空间

为什么要用垃圾回收机制：
	程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽（内存溢出），导致程序崩溃，因此管理内存是一件重要且繁杂的事情，而python解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来。
```



堆区与栈区

![image-20200718095916063](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20200718095916063.png)

 ```pytohn
直接引用：
	直接引用指的是从栈区出发直接引用到的内存地址

间接引用：
	间接引用指的是从栈区出发引用到堆区后，再通过进一步引用才能到达的内存地址。

引用计数:
	引用计数就是：变量值被变量名关联的次数，若引用次数为零，则变量就会被回收


标记清除：
	用来解决循环引用带来的内存泄露问题
	循环引用=>导致内存泄露

分代回收：
	用来降低引用计数的扫描频率，提升垃圾回收的效率
 ```

用户交互

```python
用户交互：
    用户交互就是人往计算机中input/输入数据，计算机print/输出结果
    在Python3：input会将用户输入的所有内容都存成字符串类型
    在python2中：
         raw_input():用法与python3的input一模一样
         input(): 要求用户必须输入一个明确的数据类型，输入的是什么类型，就存成什么类型

    接收用户的输入
        input()：可以让用户输入
            int：整数类型(integer)
            str：字符串类型(string)
            str()：把数据转成str类型
            int()：把字符串转成int类型
    注：input接收的所有数据都是字符串，即便你输入的是数字，但依然会被当成字符串来处理，字符串和数字类型不可以拼接在一起

```

格式化输出

```python
格式化输出：
	什么是格式化输出：
		把一段字符串里面的某些内容替换掉之后再输出，就是格式化输出。
	如何格式化输出：
		%号格式化字符串的方式从Python诞生之初就已经存在，时至今日，python官方也并未弃用%号，
		但也并不推荐这种格式化方式。因为当需格式化的字符串过多时，位置极容易搞混
				
    占位符：%s、%d
        %s占位符：可以接收任意类型的值
        %d占位符：只能接收数字
            例：
                print('%s您好，你的账号余额为%d,q请及时充值' %('小明',10))
                注：占位符与后面传入数值的%之间没有逗号，不然会有语法错误，不可以传入变量
                值按照位置与%s一一对应，少一个不行，多一个也不行
                以字典的形式传值，打破位置的限制
                res="我的名字是 %(name)s 我的年龄是 %(age)s" %{"age":"18","name":'egon'}

        print('hello world')
        print(type())                    #打印类型
        print(id())                       #打印ID
            换行符： \n
            end： 自定义换行符
                print('hello\n',end='')
                print('word')
       .        print('hello',end='*')
				print('world',end='*')
				
			
str.format
    该format方法是在Python 2.6中引入的，是字符串类型的内置方法。
    因为str.format的方式在性能和使用的灵活性上都比%号更胜一筹，所以推荐使用
    使用位置参数，按照位置一一对应
        print('{} asked {} to do something'.format('lili', 'egon'))  # lili asked egon to do something

    使用索引取对应位置的值：
        print('{0}{0}{1}{0}'.format('x','y')) # xxyx

    使用关键字参数or字典：
        可以通过关键字or字典方式的方式格式化，打破了位置带来的限制与困扰
        print('我的名字是 {name}, 我的年龄是 {age}.'.format(age=18, name='egon'))
        kwargs = {'name': 'egon', 'age': 18}
        print('我的名字是 {name}, 我的年龄是 {age}.'.format(**kwargs)) # 使用**进行解包操作
			
    填充与格式化：
        先取到值,然后在冒号后设定填充格式：[填充字符][对齐方式][宽度]

        *<10：左对齐，总共10个字符，不够的用*号填充
            print('{0:*<10}'.format('开始执行'))    #开始执行******

        *>10：右对齐，总共10个字符，不够的用*号填充
            print('{0:*>10}'.format('开始执行'))    # ******开始执行

        *^10：居中显示，总共10个字符，不够的用*号填充
            print('{0:*^10}'.format('开始执行'))    # ***开始执行***
			
    进制转换：
        十进制转二进制：bin(11)
        十进制转八进制：oct(11)
        十进制转十六进制：hex(11)
        二进制转十进制：int('0b1011',2)
        二进制转八进制：int('0o13',8)
        二进制转十六进制：int('0xb',16)
    示例：
        print('{salary:.3f}'.format(salary=1232132.12351))  #精确到小数点后3位，四舍五入，结果为：1232132.124
        print('{0:b}'.format(123))  # 转成二进制，结果为：1111011
        print('{0:o}'.format(9))  # 转成八进制，结果为：11
        print('{0:x}'.format(15))  # 转成十六进制，结果为：f
        print('{0:,}'.format(99812939393931))  # 千分位格式化，结果为：99,812,939,393,931
				
    f-Strings:
        str.format() 比 %格式化高级了一些，但是它还是有自己的缺陷。当需要传入的字符串过多时，仍然会显得
        非常冗长。在Python 3.6中引入 了f-strings，不仅比str.format更简洁，性能上也更胜一筹。python3.5以后才推出

        ​ f-string是以f或F开头的字符串， 核心在于字符串中符号{}的使用，其中{}中可以是变量名，表达式
        详情参考：https://zhuanlan.zhihu.com/p/110406030

```

基本运算符

算数运算符

| 算数运算符 |                    描述                    | 示例（x=9，y=2） |
| :--------: | :----------------------------------------: | :--------------: |
|     +      |              加，两个对象相加              |     x+y得11      |
|     -      |              减，两个对象相减              |     y-x得-7      |
|     *      |              乘，两个对象相乘              |     x*y得18      |
|     /      | 除，相除后得到的返回值会保留整数与小数部分 |     x/y得4.5     |
|     //     |   取整，相除后得到的返回值只保留整数部分   |     x//y得4      |
|     %      |           取余，相除后只返回余数           |      x%y得1      |
|     **     |            幂，取一个数的n次方             |     x**y得81     |

比较运算符

| 比较运算符 |                     描述                      |  示例  |
| :--------: | :-------------------------------------------: | :----: |
|     ==     |  等于，两个对象相等则返回True，否则返回false  |  x==y  |
|     !=     | 不等于，两个对象相等则返回False，否则返回Tuer |  x!=y  |
|     \>     |                     大于                      | x > y  |
|    \>=     |                   大于等于                    | x >= y |
|     <      |                     小于                      | x < y  |
|     <=     |                   小于等于                    | x <=y  |

赋值运算符

| 赋值运算符 |      描述      |            示例             |
| :--------: | :------------: | :-------------------------: |
|     =      |  简单赋值运算  |           x = 10            |
|     +=     |  加法赋值运算  | x = 10，x +=1 #等同于x= x+1 |
|     -=     |  减法赋值运算  |            同上             |
|     *=     |  乘法赋值运算  |            同上             |
|     /=     |  除法赋值运算  |            同上             |
|    //=     | 取整除赋值运算 |            同上             |
|     %=     |  取余赋值运算  |            同上             |
|    **=     |   幂赋值运算   |            同上             |

```Python
链式赋值：
    把一个值同时赋值给多个变量
    x=1,y=2,c=3等同于x=y=z=3

交叉赋值：
    若两个变量想交换值
    x=1  y=2   交换为x=2  y=1
    x,y = y,x
    
解压赋值：
    若想把列表中的多个值取出来依次赋值给多个变量
    nums=[11,22,33,44,55]，若一个一个的取值太麻烦
    解压赋值
        a,b,c,d,e=nums   # nums包含多个值，就好比一个压缩包，解压赋值因此得名
        解压赋值，等号左边的变量名个数必须与右面包含值的个数相同,否则会报错
    若只想取头尾的几个值可以用*匹配，但是无法匹配中间的值
        a,b,*_=nums            #没有取的值，会存成列表，然后赋值给*后面的那个值
    字符串、字典、元组、集合类型都支持解压赋值
    解压字典默认解压出来的是字典的key

```

逻辑运算符：

​		三者的优先级关系：not>and>or，同一优先级默认从左往右计算

| 逻辑运算符 |                             描述                             |  示例   |
| :--------: | :----------------------------------------------------------: | :-----: |
|    and     | 逻辑与，用于连接两个条件，两个条件同时成立时才返回true，  但凡有一个条件为falase则返回false | a and b |
|     or     | 逻辑或，用于连接两个条件，两个条件但凡有一个条件成立  则返回true，只有在两个条件同时为false时，才返回false | a or b  |
|    not     |                    逻辑非，用于对结果取反                    | a not b |

```python
and or not使用原则
	数字非零的都是真，小数负数都是真
	and运算都为真的时候，取and后面的
	and运算都为假的时候，取and前面的
	or运算，只要有一个为真，结果就为真
	or运算都为真的时候，取or前面的
	or运算都为假的时候，取or后面的
```



成员运算符：

| 成员运算符 |                             描述                             | 示例 |
| :--------: | :----------------------------------------------------------: | :--: |
|     in     | 某一个对象包含于另外一个对象则返回True  字符串，列表，元组，字典，集合都支持成员运算 |      |
|   not in   |          某一个对象没有包含于另外一个对象则返回True          |      |

 

身份运算符：

| 身份运算符 |                   描述                   | 示例 |
| :--------: | :--------------------------------------: | :--: |
|     is     | is比较的是ID，两个对象的ID相同则返回True |      |
|   is not   |   在两个对象的ID不同时is not会返回true   |      |

```pytohn
注： ==双等号比较的是value是否相等，而is比较的是id是否相等
	id相同，内存地址必定相同，意味着type和value必定相同
	value相同type肯定相同，但id可能不同
	
短路运算：
	当计算到某个位置时候，已经得出结论，则不再进行运算

```



位运算符

| 位运算符 |                             描述                             | 示例 |
| :------: | :----------------------------------------------------------: | :--: |
|    &     |                            按位与                            |      |
|    \|    |                            按位或                            |      |
|    ~     | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**~x** 类似于 **-x-1** |      |
|    ^     |           按位异或  两个值不一样,返回真,否则返回假           |      |
|    <<    | 左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0。 |      |
|    >>    | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，**>>** 右边的数字指定了移动的位数 |      |

```python
运算符总结:
    (1) 个别运算符:
        优先级最高 ** 幂运算
        优先级最低 =  赋值运算符
        () 括号可以提升运算优先级

    (2) 整体 一元运算符 > 二元运算符
        一元运算符: 同一时间,只操作一个值 - ~
        二元运算符: 同一时间,操作两个值 + - * / ...

    (3) 同一层级
        逻辑: () > not > and > or
        算数: 乘除 > 加减
        位运算符: ( << >> ) > & > ^ > |

    (4) 其他运算符
        算数运算符 > 位运算符 > 比较运算符 > 身份运算符> 成员运算符 > 逻辑运算符
        赋值运算符是最后算完进行赋值,做收尾工作的.
        
	a = 60            # 60 = 0011 1100 
    b = 13            # 13 = 0000 1101 
    c = 0

    c = a & b;        # 12 = 0000 1100
    print "1 - c 的值为：", c

    c = a | b;        # 61 = 0011 1101 
    print "2 - c 的值为：", c

    c = a ^ b;        # 49 = 0011 0001
    print "3 - c 的值为：", c

    c = ~a;           # -61 = 1100 0011
    print "4 - c 的值为：", c

    c = a << 2;       # 240 = 1111 0000
    print "5 - c 的值为：", c

    c = a >> 2;       # 15 = 0000 1111
    print "6 - c 的值为：", c
```

可变不可变类型

```python
可变不可变类型：
    可变类型：
        值改变，id不变，证明改的是原值，证明原值是可以被改变的
    不可变类型：
        值改变，id也变了，证明是产生新的值，压根没有改变原值，证明原值是不可以被修改的

    总结：
        int、float、str都被设计成了不可分割的整体，不能够被改变
		只有list和dict是可变类型，其它的都是不可变类型
```

显式布尔值与隐式布尔值

```python
显式布尔值与隐式布尔值：
	显式布尔值：
    	True、False
	隐式布尔值：所有数据类型，其中0、None、空为假
		0、None、空(空字符串、空列表、空字典)=》代表的布尔值为False，其余都为真
```

