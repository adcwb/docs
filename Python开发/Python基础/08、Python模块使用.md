

### 模块简介

```python
什么是模块：
    在Python文件中，一个py文件就是一个模块，文件名m.py，模块名就叫m，导入模块可以引用模块中已经写好的功能
    模块就是一系列功能的集合体,分为三大类：
        1、内置模块
        2、第三方模块
        3、自定义模块
    内置与第三的模块拿来就用，无需定义，这种拿来主义，可以极大地提升自己的开发效率
    自定义的模块可以将程序的各部分功能提取出来放到一模块中为大家共享使用，减少了代码冗余，程序组织结构更加清晰
    模块的产生：
        1、使用Python编写的py文件
        2、已被编译为共享库或DLL的c或c++扩展
        3、把一系列模块组织到一起的文件夹（注：文件夹下有一个__init__.py文件，该文件夹称之为包）
        4、使用C编写并链接到Python解释器的内置模块

```

### 模块的使用

```python
    import语句：
        示例：
            #文件名：foo.py
            x=1
            def get():
                print(x)
            def change():
                global x
                x=0
            class Foo:
                def func(self):
                   print('from the func')

        首次导入模块发生的三件事：
            1、执行源文件代码
            2、产生一个新的名称空间，用于存放源代码在执行过程中产生的名字
            3、在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀

        导入模块：
            import foo #导入模块foo
            a=foo.x #引用模块foo中变量x的值赋值给当前名称空间中的名字a
            foo.get() #调用模块foo的get函数
            foo.change() #调用模块foo中的change函数
            obj=foo.Foo() #使用模块foo的类Foo来实例化，进一步可以执行obj.func()

            加上foo.作为前缀就相当于指名道姓地说明要引用foo名称空间中的名字，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，并且若当前执行文件的名称空间中存在x，执行foo.get()或foo.change()操作的都是源文件中的全局变量x。
            
注：
    第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名。

    在Python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作。

    模块名应该遵循小写形式，标准库从python2过渡到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式。

    若需要在一个py文件中导入多个模块，可以写多行import语句，也可以在一行导入多个，用逗号分隔开
    一般情况下，为了语法整洁，推荐一行只导入一个模块，通常在文件开头导入，并且分类导入
        1、先导入Python内置模块
        2、导入第三方模块
        3、最后导入自定义模块
    我们同样可以在函数内导入模块，对比在文件开头导入模块属于全局作用域，在函数内导入的模块则属于局部的作用域

    from-import语句：
        from-import和import语句的区别：
            from-import导入的模块，可以在当前直接引用模块，无需加模块名
            import导入的模块，在当前文件直接引用时，需要加上模块名
                from foo import x,get,change     #将模块foo中的x和get导入到当前名称空间
                a=x             #直接使用模块foo中的x赋值给a
                get()            #直接执行foo中的get函数
                change()      #即便是当前有重名的x，修改的仍然是源文件中的x
            虽然无需加前缀使得代码更加简洁，但是容易与当前名称空间中的名字冲突，如果当前名称空间中存在相同的名字，则定义的名字会覆盖之前定义的名字。
        使用：
            from foo import *      #导入foo模块中的所有名字
            from foo import x      #仅导入foo模块下的x，相当于foo.x
            这种导入的方法只能在模块最顶层使用的方式导入，在函数内则非法，并且*的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思

            ？？？
    as：
        在当前文件中导入模块的时候起一个别名，以后再使用的时候，直接使用别名就可以
            import foo as f
            from foo import get as get_x
        通常在导入的名字过长的时候才会采用起别名的方式来精简代码；另外为被导入的名字起别名可以很好地避免与当前名字发生冲突，还有很重要的一点就是：可以保持调用方式的一致性，例如我们有两个模块json和pickle同时实现了load方法，作用是从一个打开的文件中解析出结构化的数据，但解析的格式不同，可以用下述代码有选择性地加载不同的模块
            if data_format == 'json':
                import json as serialize #如果数据格式是json，那么导入json模块并命名为serialize
            elif data_format == 'pickle':
                import pickle as serialize #如果数据格式是pickle，那么导入pickle模块并命名为serialize

            data=serialize.load(fn) #最终调用的方式是一致的

```

### 循环导入带来的问题

```python
	循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码

    解决方案：
        方案一：
            将程序中导入的语句放在最后，保证导入的时候所有的名字都已经加载过
        方案二：
            将导入语句放到函数中，只有在调用函数时才会执行其内部代码
    注：
		循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入

```

### 搜索模块的路径与优先级：

```python
    模块的四个通用类别：
        1、使用纯Python代码编写的py文件
        2、包含一系列模块的包
        3、使用C编写并链接到Python解释器中的内置模块
        4、使用C或C++编译的扩展模块
        
    在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。
    sys.path也被称为模块的搜索路径，它是一个列表类型，列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.zip或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可。
    sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中
        import sys
        sys.path.append(r'/pythoner/projects/') #也可以使用sys.path.insert(……)

    	import foo #无论foo.py在何处,我们都可以导入它了
```

### 区分Python文件的两种方式

```python
区分py文件的两种方式：
    一个Python文件有两种用途
        一种被当主程序/脚本执行
        另一种被当模块导入
        
    为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当做脚本执行时赋值为“__main__”,在py文件被当做模块导入时赋值为模块名

    作为模块的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑
        if __name__ == '__main__':
            foo.py被当做脚本执行时运行的代码
        else:
            foo.py被当做模块导入时运行的代码
            
    通常我们会在if的子代码块中编写针对模块功能的测试代码，这样foo.py在被当做脚本运行时，就会执行测试代码，而被当做模块导入时则不用执行测试代码。

```

### 编写一个规范的模块

```python
    我们在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下

    #!/usr/bin/env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。

    "The module is used to..." #模块的文档描述

    import sys #导入模块

    x=1 #定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能

    class Foo: #定义类,并写好类的注释
        'Class Foo is used to...'
        pass

    def test(): #定义函数,并写好函数的注释
        'Function test is used to…'
        pass

    if __name__ == '__main__': #主程序 
        test() #在被当做脚本执行时,执行此处的代码

```





