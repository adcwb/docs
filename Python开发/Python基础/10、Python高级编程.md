### 封装

```python
什么是封装：
	面向对象编程有三大特性：封装、继承、多态，其中最重要的一个特性就是封装
	封装指的就是把数据与功能都整合到一起，我们之前所说的”整合“二字其实就是封装的通俗说法。除此之外，针对封装到对象或者类中的属性，我们还可以严格控制对它们的访问，分两步实现：隐藏与开放接口

隐藏属性：
	Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成“_类名__属性名”的形式：
        class Foo:
            __N=0 # 变形为_Foo__N
            def __init__(self): # 定义函数时，会检测函数语法，所以__开头的属性也会变形
                self.__x=10 # 变形为self._Foo__x
            def __f1(self): # 变形为_Foo__f1
                print('__f1 run')
            def f2(self):  # 定义函数时，会检测函数语法，所以__开头的属性也会变形
                self.__f1() #变形为self._Foo__f1()

        print(Foo.__N) # 报错AttributeError:类Foo没有属性__N
        obj = Foo()
        print(obbj.__x) # 报错AttributeError:对象obj没有属性__x
需要注意以下几点：
	1、在类外部无法直接访问双下划线开头的属性，但是知道类名和属性名的情况下可以拼出来，这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形
    2、在类内部是可以直接访问双下滑线开头的属性的，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形。
    3、变形操作只在类定义阶段发生一次，在类定义之后的赋值操作不会变形

开放接口：
	定义属性是为了用，所以说隐藏并不是目的
    将数据隐藏起来，就限制了类外部对数据的直接操作，然后类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制
    class Teacher:
     def __init__(self,name,age): #将名字和年纪都隐藏起来
         self.__name=name
         self.__age=age
     def tell_info(self): #对外提供访问老师信息的接口
         print('姓名:%s,年龄:%s' %(self.__name,self.__age))
     def set_info(self,name,age): #对外提供设置老师信息的接口，并附加类型检查的逻辑
         if not isinstance(name,str):
            raise TypeError('姓名必须是字符串类型')
         if not isinstance(age,int):
             raise TypeError('年龄必须是整型')
         self.__name=name
         self.__age=age
	隐藏函数属性：
    	目的的是为了隔离复杂度，例如ATM程序的取款功能,该功能有很多其他功能组成，比如插卡、身份认证、输入金额、打印小票、取钱等，而对使用者来说,只需要开发取款这个功能接口即可,其余功能我们都可以隐藏起来
        class ATM:
             def __card(self): #插卡
                 print('插卡')
             def __auth(self): #身份认证
                 print('用户认证')
             def __input(self): #输入金额
                 print('输入取款金额')
             def __print_bill(self): #打印小票
                 print('打印账单')
             def __take_money(self): #取钱
                 print('取款')
             def withdraw(self): #取款功能
                 self.__card()
                 self.__auth()
                 self.__input()
                 self.__print_bill()
                self.__take_money()
                
	隐藏属性与开放接口，本质就是为了明确地区分内外，类内部可以修改封装内的东西而不影响外部调用者的代码；而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。这就提供一个良好的合作基础，只要接口这个基础约定不变，则代码的修改不足为虑。
    
property:
	Python专门提供了一个装饰器property，可以将类中的函数“伪装成”对象的数据属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果
    使用property有效地保证了属性访问的一致性。另外property还提供设置和删除属性的功能
        class Foo:
        def __init__(self, val):
            self.__NAME = val   #将属性隐藏起来

            @property
            def name(self):
                return self.__NAME
            @name.setter
            def name(self,value):
                if not isinstance(value,str):  #在设定值之前进行类型检查
                    raise TypeError('%s must be str' %value)
                self.__NAME = value #通过类型检查后，将值value存放到真实的位置
            @name.deleter
            def name(self):
                raise PermissionError('Can not delete')

```

### 继承与派生：

 ```python
什么是继承：
	继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类，在python中支持多继承
    class ParentClass1: #定义父类
        pass
    class ParentClass2: #定义父类
        pass
    class SubClass1(ParentClass1): #单继承
        pass
    class SubClass2(ParentClass1,ParentClass2): #多继承
        pass
    可以通过内置的属性__bases__查看类继承的所有父类
    在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类。而在Python3中，即使没有显式地继承object，也会默认继承该类，因此在Python3中统一都是新式类
		object类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__
	继承用来解决类与类之间代码冗余问题
多继承：
	优点：
		子类可以同时遗传多个父类的属性，最大限度地重用代码
	缺点：
		1、违背人的思维习惯：继承表达的是一种什么"是"什么的关系
		2、代码可读性会变差
		3、不建议使用多继承，有可能会引发可恶的菱形问题，扩展性变差，
			如果真的涉及到一个子类不可避免地要重用多个父类的属性，应该使用Mixins
属性查找：
	对象在查找属性时，先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找
        class Foo:
             def f1(self):
                 print('Foo.f1')
             def f2(self):
                 print('Foo.f2')
                 self.f1()

        class Bar(Foo):
             def f1(self):
                 print('Bar.f1')
	b.f2()会在父类Foo中找到f2，先打印Foo.f2,然后执行到self.f1(),即b.f1()，仍会按照：对象本身->类Bar->父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Bar.f1

菱形问题：
	大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的 Diamond problem菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)
    A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。

继承原理：
	对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表
    新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法
    python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:
        1、子类会先于父类被检查
        2、多个父类会根据它们在列表中的顺序被检查
        3、如果对下一个类存在两个合法的选择,选择第一个父类
注意： 
    1、由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，
    2、由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去
    
深度优先和广度优先
	深度优先：一条道路走到底
    广度优先：最后再查找根类
    经典类：深度优先，会在检索第一条分支的时候就直接一条道走到黑，即会检索大脑袋（共同的父类）
    新式类：广度优先，会在检索最后一条分支的时候检索大脑袋
	当类是经典类的时候，多继承的情况下，在要查找的属性不存在的时候，会按照深度优先的方式查找下去
    	python2中，未继承object的类及其子类，都是经典类
	当类是新式类的时候，多继承情况下，在要查找属性不存在的时候，会按照广度优先的方式查找下去
    
Mixins机制
	核心：
    	在多继承背景下尽可能地提升多继承的可读性
        让多继承满足人的思维习惯，“什么”是“什么”
        简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属"is-a"关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系
        class Vehicle:  # 交通工具
            pass
        class FlyableMixin:
            def fly(self):
                '''
                飞行功能相应的代码        
                '''
                print("I am flying")
        class CivilAircraft(FlyableMixin, Vehicle):  # 民航飞机
            pass
        class Helicopter(FlyableMixin, Vehicle):  # 直升飞机
            pass

        class Car(Vehicle):  # 汽车
            pass
        # ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路
        
使用Mixin类实现多重继承要非常小心
    1、首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀
    2、其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类
    3、然后，它不依赖于子类的实现
    4、最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）
    
=========================================================================================
派生与方法重用
	在子类派生的新方法中如何重用父类的功能
    方法一：指名道姓调用某一个类下的函数，不依赖于继承关系
	方式二：super()调用父类提供给自己的方法=》严格依赖继承关系
		调用super()会得到一个特殊的对象，该对象会参照发起属性查找的那个类的mro,去当前类的父类中找属性

        
=========================================================================================
组合：
	什么是组合：
    	在一个类中以另外一个类的对象作为数据属性，称为类的组合
        组合与继承都是用来解决代码的重用性问题
	组合与继承的区别：
    	继承是一种“是”的关系，比如苹果是水果
        组合则是一种“有”的关系，比如学生有属性
 ```

### 多态性与鸭子类型：

 ```python
多态：
	多态指的是同一类事物有多种形态
	多态性指的是可以在不考虑对象具体类型的情况下而直接使用对象
    多态性的好处在于增强了程序的灵活性和可扩展性
    多态性的本质在于不同的类中定义有相同的方法名，这样我们就可以不考虑类而统一用一种方式去使用对象，可以通过在父类引入抽象类的概念来硬性限制子类必须有某些方法名
鸭子类型：
	
 ```

### 绑定与非绑定方法：

 ```python
绑定方法：
	特殊之处在于将调用者本身当做第一个参数自动传入
    绑定方法又分为绑定到对象的对象方法和绑定到类的类方法
    	绑定给对象的方法：调用者是对象，自动传入的是对象
        绑定给类的方法：调用者类，自动传入的是类
	在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@classmethod后，该函数就绑定到了类
    绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用是没有意义的，并且容易引起混淆
    
非绑定方法：
	为类中某个函数加上装饰器@staticmethod后，该函数就变成了非绑定方法，也称为静态方法
    该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值那么一说
    
总结：
	若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法
    
 ```

### 反射

 ```python
    什么是反射：	
    
        Python是一门动态语言，而反射(reflection)机制被视为动态语言的关键
        反射机制指的是在程序的运行状态中
            - 对于任意一个类，都可以知道这个类的所有属性和方法；
            - 对于任意一个对象，都能够调用他的任意方法和属性。
        这种动态获取程序信息以及动态调用对象的功能称为反射机制。
        通俗的说，反射就是通过字符串去操作类对象或者模块当中的成员(属性或者方法)

    hasattr：
        检测对象或类中是否有指定的成员
    getattr：
        获取对象或类成员的值
    setattr：
        设置对象或类的成员的值
    delattr：
        删除对象或成员的值

        class Teacher:
        def __init__(self,full_name):
            self.full_name =full_name

        t=Teacher('Egon Lin')

        # hasattr(object,'name')
        hasattr(t,'full_name') # 按字符串'full_name'判断有无属性t.full_name

        # getattr(object, 'name', default=None)
        getattr(t,'full_name',None) # 等同于t.full_name,不存在该属性则返回默认值None

        # setattr(x, 'y', v)
        setattr(t,'age',18) # 等同于t.age=18

        # delattr(x, 'y')
        delattr(t,'age') # 等同于del t.age

        基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行
        通过对象反射出来的方法是个绑定方法
        通过类反射出来的方法是个普通方法
        反射的成员不存在时,可以设置一个默认值防止报错
        反射可以针对模块中的成员

 ```

### 元类：

  ```python

  ```

### 抽象类：

```Python

```

